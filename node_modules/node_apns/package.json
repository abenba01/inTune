{
  "name": "node_apns",
  "description": "Apple Push Notifier for node.js",
  "version": "0.0.5",
  "author": {
    "name": "Thierry Passeron",
    "email": "thierry.passeron@gmail.com"
  },
  "keywords": [
    "Apple",
    "push",
    "notification",
    "iOS",
    "apns"
  ],
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/Orion98MC/node_apns.git"
  },
  "readme": "# Apple Push Notifier for node.js\n\nnode_apns helps you send notifications to iOS devices through Apple's Push Notification Service from Node.js (http://nodejs.org/).\n\n# Key Features\n\n* On demand Persistant Connections\n* EventEmitter Objects\n* Handle Enhenced and Simple notifications format\n* 20 seconds to get going...\n\n\n## 20 Seconds Setup\n\nThe easiest way to get notifications going is to use the provided Notifier service. You instantaneously get:\n\n* On demand connections to Apple (if the connection is stale it is remade automatically)\n* Automatic feedback queries on startup\n* Blacklist of erroneous tokens and feedback tokens\n* Auto recover on notification error\n* Callback when notification is accepted by Apple (and not just written to the socket) or when an error occures\n* Now you _can_ go to the coffee machine...\n\n=> find more in the source file _services.js_\n\n### Sample Usage\n\n```js\n\nvar \n  cert_and_key = require('fs').readFileSync('/Users/orion/identity-dev.pem')\n  notifier = require('node_apns').services.Notifier({ cert: cert_and_key, key: cert_and_key }, true /* development = true, production = false */)\n  \n  \n /* \n   Now you may send notifications!\n */\n \n var Notification = require('node_apns').Notification;\n \n notifier.notify(Notification(\"8badf00d\", { aps: { alert: \"Hello from service\", sound: \"default\" }}), \n   function (err) { \n     if (!err) console.log(\"Sent\", this); \n     else console.log('Error', err, 'on', this);\n   }\n );\n \n\n```\n\n\n# API\n## Push\n### Example\n\nFirst, require *node_apns*\n\n```js\nvar Push = require('node_apns').Push;\n```\n\nCreate a new on-demand push connexion\n\n```js\nvar push = Push({\n\tcert: require('fs').readFileSync('./cert.pem'), \n\tkey: require('fs').readFileSync('./key.pem')\n});\n```\n\nRegister for events\n\n```js\npush.on('sent', function (notification) {\n\n\t// The notification has been sent to the socket (it may be buffered if the network is slow...)\n\tconsole.log('Sent', notification);\n\n});\n\npush.on('notificationError', function (errorCode, uid) {\n\n\t// Apple has returned an error:\n\tconsole.log('Notification with uid', uid, 'triggered an error:', require('node_apns').APNS.errors[errorCode]);\n\n});\n\npush.on('error', function (error) { console.log('Yipikaye!', error); });\n```\n\nCreate a new Notification\n\n```js\nvar Notification = require('node_apns').Notification\n,\tn = Notification(\"abcdefghabcdefgh\", {foo: \"bar\", aps:{\"alert\":\"Hello world!\", \"sound\":\"default\"}});\n                      /*  ^----- fake device token hex string */\n```\n\nSend the notification\n\n```js\nif (n.isValid()) push.sendNotification(n);\n```\n\n\nThe connexion is on-demand and will only be active when a notification needs to be sent. After a first notification, it will stay opened until it dies. When it dies, a new notification will trigger the re-connexion.\n\nFor everything to work nicely, you should register for 'error' events (push.on('error', function() {...})) to prevent the node's runloop from throwing exceptions when they occur.\n\n### Constructor\n\n\tPush(tls_options, options)\n\n\ttls_options: {cert:cert_data, key:key_data [,...]} // See Node.js documentation at http://nodejs.org/api/tls.html#tls_tls_connect_options_secureconnectlistener\n\n\toptions: {\n\t\thost:<gateway-host | APNS.production.host>, \n\t\tport:<gateway-port | APNS.production.port>, \n\t\tenhenced:<Bool | true>, /* enhenced notifications or not */\n\t\tverbose:<Bool | false>\n\t}\n\n### Events\n\nPush objects emit these events:\n\n* 'clientError' (exception) when a client error occured before connexion\n* 'authorized' when connected and authorized\n* 'error' (exception) when an error/exception occurs (ENOENT EPIPE etc...)\n* 'end' when the server ended the connexion (FIN packet)\n* 'close' when the server closed the connexion\n* 'notificationError' (String errorCode, notificationUID) when Apple reports a *bad* notification\n* 'buffer' when the cleartextStream.write() returned false (meaning it is now buffering writes until next 'drain')\n* 'drain' when the cleartextStream is not buffering writes anymore\n* 'sent' (notification) when a notification has been written to the cleartextStream\n\n### Additional methods\n\n* push.close([Bool now]): force the closing of a connexion. If now is not specified (default), \"After the write queue is drained, close\".\n\n\n## Feedback\n\nCreate an immediate feedback connexion\n\n```js\nvar feedback = require('node_apns').Feedback({cert:cert_data, key:key_data});\n\nfeedback.on('device', function (time, token) {\n\tconsole.log('Token', token, 'did not respond to notification on', new Date(time * 1000));\n});\n\nfeedback.on('end', function () {\n\tconsole.log('Done');\n});\n```\n\n### Constructor\n\n\tFeedback(tls_options, options)\n\n\ttls_options: {cert:cert_data, key:key_data [,...]} // See Node.js documentation at http://nodejs.org/api/tls.html#tls_tls_connect_options_secureconnectlistener\n\n\toptions: {\n\t\thost:<gateway-host | APNS.feedback.host>, \n\t\tport:<gateway-port | APNS.feedback.port>, \n\t\t\n\t\tbufferSize:<uint | 1>, /* size of tuple buffer in tuples unit */\n\t\tverbose:<Bool | false>\n\t}\n\nA feedback connexion is stopped by Apple when no more devices are to be reported.\n\n### Events\n\nFeedback objects emit these events:\n\n* 'clientError' (exception) when a client error occured before connexion\n* 'error' (exception) when an error/exception occurs (ENOENT EPIPE etc...)\n* 'end' when the server ended the connexion (FIN packet)\n* 'close' when the server closed the connexion\n* 'device' (uint time, String token) when a device token is reported by Apple\n\n\n## Notification\n\nYou can create Notification objects many different ways:\n\n```js\nvar Device = require(\"node_apns\").Device\n,\ttokenString = \"abcdefghabcdefgh\";\n\n// Create a notification with no device and no payload\nn = Notification(); \n\t// then...\n\tn.device = Device(tokenString); \n\tn.alert = \"Hello world!\";\n\n// Create a notification with no payload\nn = Notification(tokenString); \n\t// then...\n\tn.alert = \"Hello world!\";\n\tn.badge = 1;\n\n// Create a notification with device and payload\nn = Notification(tokenString, {foo: \"bar\"});\n\t// then...\n\tn.alert = \"Hello world!\";\n\tn.sound = \"default\";\n\n// Create a notification with device and full payload\nn = Notification(tokenString, {foo: \"bar\", aps:{alert:\"Hello world!\", sound:\"bipbip.aiff\"}});\n```\n\n### Accessors\n\n#### Payload properties\n\n* notification.alert\n* notification.badge\n* notification.sound\n\nIf you need to specify a custom key, then use:\n\n* notification.payload = {...custom-content...}\n\nExample:\n\n```js\nn = Notification();\nn.payload = {\n\tfrom: \"terminator\",\n\tto: \"rocky-balboa\"\n};\nn.alert = \"Diner tonight?\";\nn.sound = \"TheLoveBoat.aiff\";\n```\n\nBeware that notification.{alert|badge|sound} will overwrite the content of notification.payload.aps if it exists prior to using them.\n\n#### Other properties\n\n* notification.device: get or set the Device object\n* notification.encoding: get or set the notification encoding (default is \"utf8\")\n\n#### Enhenced notification properties\n\n* notification.expiry: get or set the enhenced notification expiry\n* notification.identifier: get the notification unique identifier as set (by the push object) when written to the cleartextStream\n\n\n### Checkings\n\nYou should always check the notification's validity before sending it.\n\n```js\nif (n.isValid()) { push.sendNotification(n); } \nelse {\n\tconsole.log(\"Malformed notification\", n);\n\t// ... investigate ...\n}\n```\n\n## Device\n\n```js\n// Create a device object with a token (hex) String\nd = Device(\"abcdefabcdef\");\n\n// Create a device object with a Buffer (binary) token\nvar buffer = new Buffer(32);\nd = Device(buffer);\n```\n\n### Checkings\n\nThe token string must be a valid hex string. You can check it with the isValid() method:\n\n```js\nif (d.isValid()) { ... }\n```\n\n## \"Constants\"\n\nApple's service define some properties that are accessible through the APNS exports\n\n```js\nvar APNS = {\n\t/*\n\t\tSOURCE: http://developer.apple.com/library/ios/#DOCUMENTATION/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingWIthAPS/CommunicatingWIthAPS.html\n\t*/\n\n\tdevelopment: {\n\t\thost: 'gateway.sandbox.push.apple.com',\n\t\tport: 2195\n\t},\n\tproduction: {\n\t\thost: 'gateway.push.apple.com',\n\t\tport: 2195\n\t},\n\tfeedback: {\n\t\tport: 2196,\n\t\ttupleSize: 38 /* The feedback binary tuple's size in Bytes (4 + 2 + 32) */\n\t},\n\terrors : {\n\t\t'0': 'No errors encountered',\n\t\t'1': 'Processing error',\n\t\t'2': 'Missing device token',\n\t\t'3': 'Missing topic',\n\t\t'4': 'Missing payload',\n\t\t'5': 'Invalid token size',\n\t\t'6': 'Invalid topic size',\n\t\t'7': 'Invalid payload size',\n\t\t'8': 'Invalid token',\n\t\t'255': 'None (unknown)'\n\t}\t\t\n};\n```\n\nYou can use them for example to specify a development gateway to your Push connexion (default is the production gateway)\n\n```js\nvar push = Push({cert:cert_data, key:key_data}, {\n\thost: require('node_apns').APNS.development.host\n});\n```\n\nYou can also use the errors to get a meaningful output of the errorCode provided by Apple when 'notificationError' occurs\n\n```js\n\tpush.on('notificationError', function (errorCode, notificationUID) {\n\t\tconsole.log('Notification with UID', notifcationUID, 'Error:', require('node_apns').APNS.errors[errorCode]);\n\t});\n```\n\n# License terms\n\nThe MIT License\n\nCopyright (C) 2012 Thierry Passeron\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated \ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation \nthe rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, \nand to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED \nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL \nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF \nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \nDEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "node_apns@0.0.5",
  "dist": {
    "shasum": "430c12fc4b9f2d7a32dfcf3a8dbe20567e20ddee",
    "tarball": "http://registry.npmjs.org/node_apns/-/node_apns-0.0.5.tgz"
  },
  "_from": "node_apns@*",
  "_npmVersion": "1.2.11",
  "_npmUser": {
    "name": "orion",
    "email": "thierry.passeron@gmail.com"
  },
  "maintainers": [
    {
      "name": "orion",
      "email": "thierry.passeron@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "430c12fc4b9f2d7a32dfcf3a8dbe20567e20ddee",
  "_resolved": "https://registry.npmjs.org/node_apns/-/node_apns-0.0.5.tgz"
}
